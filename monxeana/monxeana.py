
# This Python3 library contains code focussing on the analysis of MonXe stuff.



#######################################
### Imports
#######################################


import numpy as np
from scipy.integrate import odeint
import matplotlib as mpl
import matplotlib.pyplot as plt
import datetime
import pprint
import os
import random
from scipy.optimize import curve_fit
from matplotlib.ticker import AutoMinorLocator
import matplotlib.patches as patches
from PIL import Image, ImageDraw, ImageFont
from fpdf import FPDF
import matplotlib.image as mpimg
from matplotlib.offsetbox import TextArea, DrawingArea, OffsetImage, AnnotationBbox
import getpass





#######################################
### Generic Definitions
#######################################


# username
username = getpass.getuser()


# paths
if username == "daniel":
    pathstring_monxe = "/home/daniel/Desktop/arbeitsstuff/monxe/"
elif username == "monxe":
    pathstring_monxe = "/home/monxe/Desktop/"
else:
    pathstring_monxe = "./"
pathstring_measurement_folder = pathstring_monxe +"monxe_measurements/"
pathstring_output_relative = "./output/" # this is the folder (within the measurement folder) where the analysis output is stored
pathstring_data_relative = "./DAQ/run/RAW/" # this is the folder where CoMPASS stores the measurement data


# filenames
filename_data_csv = "DataR_CH0@DT5781A_840_run.csv" # timestamp (and eventually waveform) data
filename_data_txt = "CH0@DT5781A_840_EspectrumR_run.txt" # adc spectrum data
filename_histogram_png = "histogram" # histogram plot name


# format
color_uni_blue = '#004A9B'
color_uni_red = '#C1002A'
color_monxe_cyan = "#00E8E8" # the cyan-like color that was used within the MonXe logo
color_histogram = "black"
color_histogram_error = color_uni_blue
linewidth_histogram_std = 0.8 # the standard linewidth for a histogram plot


# miscellaneous
n_adc_channels = 16383 # from channel 0 to channel 16383
adc_channel_min = 0
adc_channel_max = 16382





#######################################
### Retrieving Data
#######################################


# This is the dtype used for raw data.
timestamp_data_dtype = np.dtype([
    ("timestamp_ps", np.uint64), # timestamp in ps
    ("pulse_height_adc", np.int16) # max adc channel is ~16000, np.int16 ranges from -32768 to 32767
])


# This function is used to load the .csv file that stores the timestamp information and is generated by CoMPASS.
def get_timestamp_data(
    runname,
    pathstring_data_input = "",
    flag_extractwaveforms = False,
):
    # retrieving the data pathstring
    if pathstring_data_input == "":
        pathstring_data = pathstring_measurement_folder +runname +"/" +pathstring_data_relative +filename_data_csv
    else:
        pathstring_data = pathstring_data_input
    timestamp_data_tuplelist = []
    waveform_dict = {}
    # opening the .csv file and writing the data into 'timestamp_tuple_list' or 'waveform_dict' respectively
    with open(pathstring_data) as input_file:
        for line in input_file:
            if not line.startswith("BOA"):
                line_list = list(line.split(";"))
                timestamp_ps = np.uint64(line_list[2])
                pulse_height_adc = np.uint64(line_list[3])
                # extracting just the timestamp data
                if flag_extractwaveforms == False:
                    timestamp_data_tuplelist.append((
                        timestamp_ps,
                        pulse_height_adc
                    ))
                # extracting timestamp plus waveform data
                elif flag_extractwaveforms == True:
                    waveform_dict.update({
                        str(timestamp_ps) : {
                            "timestamp_ps" : timestamp_ps,
                            "pulse_height_adc" : pulse_height_adc,
                            "waveform" : np.array(line_list[4:0])
                        }
                    })
                else:
                    print(f"'flag_extractwaveforms' invalid: {flag_extractwaveforms}")
    # returning the requested data
    if flag_extractwaveforms == False:
        return np.array(timestamp_data_tuplelist, timestamp_data_dtype)
    elif flag_extractwaveforms == True:
        return waveform_dict
    else:
        return





#######################################
### Histogram Stuff
#######################################


# This is the dtype used for histogram data.
histogram_data_dtype = np.dtype([
    ("bin_centers", np.int16), # max adc channel is ~16000, np.int16 ranges from -32768 to 32767
    ("counts", np.uint64), # better safe than sorry
    ("counts_errors", np.uint64) # better safe than sorry
])


# This function is used to calculate the Poissonian error of a number of counts.
def calc_poissonian_error(number_of_counts):
    return np.sqrt(number_of_counts)


# This function is used to convert raw timestamp data into histogram data
def get_histogram_data_from_timestamp_data(
    timestamp_data, # the timestamp data retrieved by 'get_timestamp_data'
    number_of_bins = n_adc_channels # the number of bins, per default every adc channel counts as one bin
):
    # calculating binwidth, bin centers and histogram data
    binwidth = (adc_channel_max-adc_channel_min)/(number_of_bins-1)
    data_histogram_adc_channels = np.arange(adc_channel_min, adc_channel_max +binwidth, binwidth)
    data_histogram_counts = np.histogram(a=timestamp_data["pulse_height_adc"], bins=number_of_bins, range=(adc_channel_min -0.5*binwidth, adc_channel_max +0.5*binwidth))[0]
    # casting the rebinned date into an ndarray
    histogram_data_tuplelist = []
    for i in range(len(data_histogram_adc_channels)):
        histogram_data_tuplelist.append((
            data_histogram_adc_channels[i],
            data_histogram_counts[i],
            calc_poissonian_error(data_histogram_counts[i])
        ))
    histogram_data = np.array(histogram_data_tuplelist, histogram_data_dtype)
    return histogram_data


# This function is used to stepize arbitrary histogram data.
# I.e. it takes two list-like objects representing both the bin centers and also the corresponding counts and calculates two new lists containing both the left and right edges of the bins and two instances of the counts.
def stepize_histogram_data(bincenters, counts, counts_errors=""):
    # calculating the binwidth
    binwidth = bincenters[1]-bincenters[0]
    bincenters_stepized = np.zeros(2*len(bincenters))
    counts_stepized = np.zeros(2*len(counts))
    counts_errors_stepized = np.zeros(2*len(counts))
    for i in range(len(bincenters)):
        bincenters_stepized[2*i] = bincenters[i] -0.5*binwidth
        bincenters_stepized[(2*i)+1] = bincenters[i] +0.5*binwidth
        counts_stepized[2*i] = counts[i]
        counts_stepized[2*i+1] = counts[i]
        if counts_errors != "":
            counts_errors_stepized[2*i] = counts_errors[i]
            counts_errors_stepized[2*i+1] = counts_errors[i]
    if counts_errors != "":
        return bincenters_stepized, counts_stepized, counts_errors_stepized
    else:
        return bincenters_stepized, counts_stepized








